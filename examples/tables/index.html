<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Heatmap</title>
    <style>
body {
  font: 10px sans-serif;
}
line {
  stroke: #000;
}
    </style>
    <script src="/d3.v3.js"></script>
    <script src="/reorder.js"></script>
    <script src="/table.js"></script>
  </head>
  <body>
    <button type="button" onclick="random_permute()">Random Permute</button>
    <button type="button" onclick="optimal_leaf_order_permute()">Optimal Leaf Order Permute</button>
    <button type="button" onclick="max_mi()">Maximize Moran's I</button>
    <button type="button" onclick="initial_order_permute()">Initial Order</button><br>
    <label for="size">Size:</label>
    <input type="number" id="size" name="size" min="1" max="100" value="10">
    <label for="density">Density (undirected):</label>
    <input type="number" id="density" name="density" min="1" max="1000" value="12">
    <label for="diagonal">Include diagonal</label><input type="checkbox" id="diagonal" name="diagonal">
    <button type="button" onclick="generate()">Generate Matrix</button>
    <div id='heatmap'></div>
<script>

document.getElementById("diagonal").checked = true;

var margin = {top: 80, right: 0, bottom: 10, left: 80},
    width = 720 - margin.left - margin.right,
    height = 720 - margin.top - margin.bottom;

    svg = d3.select("#heatmap").append("svg")
	    .attr("width", width + margin.left + margin.right)
	    .attr("height", height + margin.top + margin.bottom)
	    .append("g")
	    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


var matrix = [[1, 0, 0, 0, 1, 0, 0, 0],
	      [0, 1, 1, 0, 0, 1, 0, 1],
	      [0, 1, 1, 0, 1, 0, 0, 0],
	      [0, 0, 0, 1, 0, 0, 1, 0],
	      [1, 0, 1, 0, 1, 0, 0, 0],
	      [0, 1, 0, 0, 0, 1, 0, 1],
	      [0, 0, 0, 1, 0, 0, 1, 0],
	      [0, 1, 0, 0, 0, 1, 0, 1]];
          
var labels = [];
    for (var i = 0; i < matrix[0].length; i++) {
        labels.push(i);
    }
    col_labels = labels;
    row_labels = labels;

      
var t1 = new table({matrix: matrix, row_labels: row_labels, col_labels: col_labels},svg);

/*
 * Shuffle taken from: https://stackoverflow.com/questions/6274339/how-can-i-shuffle-an-array
 */
function shuffle(a) {
    for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
}

function generate() {
    var size = Number(document.getElementById("size").value);
    var density = Number(document.getElementById("density").value);
    var diagonal = document.getElementById("diagonal").checked;
    var result = [];
    for(let i = 0; i<size; i++){
        result[i] = new Array(size).fill(0);
        if(diagonal){
            result[i][i] = 1;
        }
    }
    
    
    var edges = [];
    var index = 0;
    for(let i = 0; i < size; i++){
        for(let j = i+1; j < size; j++){
            edges[index] = [i,j];
            index++;
        }
    }
    const shuffled = shuffle(edges);
    
    for(let i = 0; i < density; i++){
        var u = edges[i][0];
        var v = edges[i][1];
        result[u][v] = 1;
        result[v][u] = 1;
    }
    
        
    
    matrix = result;
        
    var labels = [];
    for (var i = 0; i < matrix[0].length; i++) {
        labels.push(i);
    }
    col_labels = labels;
    row_labels = labels;
    
    
    d3.select("#heatmap").selectAll("*").remove();
    svg = d3.select("#heatmap").append("svg")
	    .attr("width", width + margin.left + margin.right)
	    .attr("height", height + margin.top + margin.bottom)
	    .append("g")
	    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    t1 = new table({matrix: matrix, row_labels: row_labels, col_labels: col_labels},svg);
}

function random_permute() {
      t1.order(reorder.randomPermutation(matrix.length),
		  reorder.randomPermutation(matrix[0].length));
}

function optimal_leaf_order_permute() {
  var transpose = reorder.transpose(matrix),
      dist_rows = reorder.dist()(matrix),
      dist_cols = reorder.dist()(transpose),
      order = reorder.optimal_leaf_order(),
      row_perm = order.distanceMatrix(dist_rows)(matrix),
      col_perm = order.distanceMatrix(dist_cols)(transpose);
      
      t1.order(row_perm, col_perm);
}

function max_mi() {
    var rows = reorder.permutation(matrix.length);

    var n = 0;
    var m = 0;
    for (var i = 0; i < matrix.length; i++) {
        for (var j = 0; j < matrix[0].length; j++) {
            n++;
            if(matrix[i][j] === 1){
                m++;
            }
        }
    }
    var best_morans = -1;
    var best_order = [];
    for (var i = 0; i < rows.length; i++) {
        var initial = rows[0];
        var res = [];
        res.push(initial);
        while(res.length < rows.length){
          var nearest = -1;
          for (var i = 1; i < rows.length; i++) {
              if(!res.includes(rows[i])){
                  var last = matrix[res[res.length-1]];
                  var r1 = matrix[rows[i]];
                  var r2 = matrix[nearest];
                  if(nearest === -1){
                      nearest = rows[i];
                  }
                  else if(weighted_value_rows(last,r1,n,m) > weighted_value_rows(last,r2,n,m)){
                      nearest = rows[i];
                  }
                  else{
                  }
              }
          }
          res.push(nearest);
        }
        t1.order(res, res);
        best_order = res;
        var oldm = 0;
        var newm = t1.quality()[3];
        while(newm-oldm > 0.0001){
            for (var i = 0; i < res.length; i++) {
                for (var j = i+2; j < res.length-1; j++) {
                    // i and i+1 and j and j+1
                    var check = [];
                    for (var n = 0; n < res.length; n++) {
                        check[n] = res[n];
                    }
                    check[i+1] = res[j];
                    check[j] = res[i+1];
                    for (var x = 0; x < (j-(i+1)); x++) {
                         check[i+1+x] = res[j-x];
                    }
                    var oldq = weighted_value_rows(matrix[res[i]],matrix[res[i+1]],n,m) + weighted_value_rows(matrix[res[j]],matrix[res[j+1]],n,m);
                    var newq = weighted_value_rows(matrix[check[i]],matrix[check[i+1]],n,m) + weighted_value_rows(matrix[check[j]],matrix[check[j+1]],n,m);
                    if(newq > oldq){
                        res = check;
                    }
                }
            }
            t1.order(res, res);
            oldm = newm;
            newm = t1.quality()[3];
            if(newm > best_morans){
                best_morans = newm;
                best_order = res;
            }
        }
    }
    t1.order(best_order, best_order);
}

function weighted_value_rows(r1,r2,cells,m){
    var result = 0;
    for (var i = 0; i < r1.length; i++) {
        result += (r1[i] * cells - m) * (r2[i] * cells - m);
    }
    return result;
}

function initial_order_permute() {
      t1.order(reorder.permutation(matrix.length),
		  reorder.permutation(matrix[0].length));
}
      
    </script>
  </body>
</html>

